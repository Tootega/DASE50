# DASE50 â€” Design-Aided Software Engineering

[![CI](https://github.com/Tootega/DASE50/actions/workflows/ci.yml/badge.svg)](https://github.com/Tootega/DASE50/actions/workflows/ci.yml)

## TFX â€” Core Framework

![TFX Tests](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/Tootega/BADGE_GIST_ID/raw/tfx-tests.json)
![TFX Coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/Tootega/BADGE_GIST_ID/raw/tfx-coverage.json)
![Node.js Version](https://img.shields.io/badge/node-%3E%3D%2020-blue.svg)
![Vitest](https://img.shields.io/badge/tested%20with-vitest-663399?logo=vitest)
![TypeScript](https://img.shields.io/badge/TypeScript-5.3+-3178C6?logo=typescript&logoColor=white)
![AI Written](https://img.shields.io/badge/written%20by-AI-blueviolet)

## DASE â€” VS Code Extension

![DASE Tests](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/Tootega/BADGE_GIST_ID/raw/dase-tests.json)
![DASE Coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/Tootega/BADGE_GIST_ID/raw/dase-coverage.json)
![Node.js Version](https://img.shields.io/badge/node-%3E%3D%2020-blue.svg)
![Jest](https://img.shields.io/badge/tested%20with-jest-C21325?logo=jest)
![TypeScript](https://img.shields.io/badge/TypeScript-5.3+-3178C6?logo=typescript&logoColor=white)
![AI Written](https://img.shields.io/badge/written%20by-AI-blueviolet)

---

## ğŸ§ª An Experiment in AI-Driven Software Development

**This project is a deliberate experiment** in writing a medium-sized software project **entirely through AI prompts**, without any direct human coding. Every line of code, test, configuration, and documentation has been generated by AI (GitHub Copilot) based on carefully crafted prompts and architectural instructions.

The goal is to explore:
- **Feasibility:** Can AI write production-quality code from high-level descriptions?
- **Quality:** Does AI-generated code meet professional standards for security, performance, and maintainability?
- **Coverage:** Can AI achieve 100% test coverage while maintaining code elegance?
- **Iteration:** How effectively can AI refactor, debug, and extend existing codebases?

> *"The best code is code that writes itself â€” guided by clear intent."*

---

## ğŸ“‹ Table of Contents

- [Project Overview](#-project-overview)
- [Philosophical Principles](#-philosophical-principles)  
- [Repository Structure](#-repository-structure)
- [DASE â€” VS Code Extension](#-dase--vs-code-extension)
- [TFX â€” Tootega Framework X](#-tfx--tootega-framework-x)
- [Code Quality Standards](#-code-quality-standards)
- [Development Guide](#-development-guide)
- [CI/CD Pipeline](#-cicd-pipeline)

---

## ğŸ¯ Project Overview

**DASE** (Design-Aided Software Engineering) is a visual design environment for modeling and generating multi-layer, multi-platform, multi-database, and multi-paradigm web applications.

The project consists of two main components:

| Component | Description | Status |
|-----------|-------------|--------|
| **[TFX/](TFX/)** | Core framework library providing the foundation for VS Code extensions | âœ… Complete |
| **[DASE/](DASE/)** | VS Code extension implementing visual designers | ğŸš§ In Development |

### Core Technologies

- **TypeScript 5.3+** with .NET-inspired conventions
- **Node.js 20+** runtime
- **Vitest** for unit testing with coverage
- **GitHub Actions** for CI/CD automation

---

## ğŸ§­ Philosophical Principles

These principles are the foundation behind every directive in this document.  
They exist to keep decisions consistent when trade-offs appear.

1. The best code is code that writes itself â€” guided by clear intent.
2. Any line of code that cannot be exercised by automated tests should not exist.
3. Truth over optics: we refuse â€œmetric theaterâ€ (coverage inflation, artificial branches, cosmetic tests).
4. Coverage is evidence, not a goal: the goal is confidence in behavior under realistic conditions.
5. If a branch is truly unreachable, the correct action is removal or an explicit invariant â€” not a fabricated test.
6. Unreachable code is a design smell: either the model is wrong, or the branch is dead, or the contract is unclear.
7. Prefer deletion to decoration: removing dead paths is higher quality than â€œcoveringâ€ them.
8. Tests must represent plausible worlds: a test that cannot occur in production is documentation of fiction.
9. Every test must answer a question: â€œWhat failure would this catch, and why would it matter?â€
10. Assertions are contracts: validate invariants where they belong, and test through public behavior.
11. Strong contracts reduce defensive noise: less â€œjust in caseâ€, more â€œcannot happen by constructionâ€.
12. Write code that is easy to prove: clarity beats cleverness; determinism beats surprises.
13. Prefer domain truth over framework convenience: the model dictates the code, not the other way around.
14. Code is a liability: every added line MUST pay rent (clear value, verified behavior).
15. Make state explicit; implicit state becomes hidden bugs.
16. Optimize for the next reader: the future maintainer is usually you.
17. Complexity must be earned by measurable benefit; simple mechanisms scale best.
18. Fail fast, fail loud: reject invalid input early with precise, actionable errors.
19. Measure before optimizing; optimize only what profiling proves is hot.
20. Security is an invariant, not a feature.
21. Integrity is non-negotiable: we do not trade truth for appearance, even when it looks â€œbetterâ€ on paper.
22. A green pipeline is not a certificate: it is a signal that must remain honest to keep meaning.
23. Just as 10 seconds of silence end a life of $3 \times 10^9$ beats, sequential errors are software's demise: continuity is life, statistics are an illusion.

---

## ğŸ“ Repository Structure

```
DASE50/
â”œâ”€â”€ .github/
â”‚   â”œâ”€â”€ copilot-instructions.md    # AI coding standards
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ tfx-ci.yml             # CI/CD pipeline
â”œâ”€â”€ TFX/                           # Core Framework
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Core/                  # Foundation classes
â”‚   â”‚   â”œâ”€â”€ Data/                  # Serialization engine
â”‚   â”‚   â”œâ”€â”€ Design/                # Visual design elements
â”‚   â”‚   â””â”€â”€ Designers/             # Domain-specific designers
â”‚   â””â”€â”€ tests/                     # Unit tests
â”œâ”€â”€ DASE/                          # VS Code Extension
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Commands/              # Extension commands
â”‚   â”‚   â”œâ”€â”€ Views/                 # Panel views
â”‚   â”‚   â”œâ”€â”€ Designer/              # ORM designer
â”‚   â”‚   â”œâ”€â”€ Services/              # Business services
â”‚   â”‚   â””â”€â”€ Models/                # Data models
â”‚   â”œâ”€â”€ media/                     # Webview assets
â”‚   â””â”€â”€ tests/                     # Unit tests
â””â”€â”€ README.md                      # This file
```

---

# ï¿½ DASE â€” VS Code Extension

**DASE** (Design-Aided Software Engineering) is a VS Code extension that provides visual designers for software modeling. The initial focus is an **ORM Designer** for database schema modeling.

## Vision

DASE aims to be a comprehensive visual design environment supporting:
- ğŸ“Š **ORM Designer** â€” Database schema modeling (current phase)
- ğŸ“ **UI Designer** â€” User interface layouts (planned)
- ğŸ”„ **Flow Designer** â€” Business process workflows (planned)
- ğŸ“¡ **API Designer** â€” REST/GraphQL endpoint modeling (planned)

## Current Phase: ORM Designer

### Features

| Feature | Description | Status |
|---------|-------------|--------|
| Custom Editor | Opens `.dsorm` files in visual designer | âœ… Implemented |
| Tables | Visual table representation with columns | âœ… Implemented |
| Relations | Visual relationship lines between tables | âœ… Implemented |
| Properties Panel | Edit selected element properties | âœ… Implemented |
| Issues Panel | Validation errors and warnings | âœ… Implemented |
| Context Menus | All actions via right-click menus | âœ… Implemented |
| TFX Integration | Bridge to TFX framework for model management | âœ… Implemented |

### Architecture

```
DASE/src/
â”œâ”€â”€ ExtensionMain.ts                  # Extension entry point
â”œâ”€â”€ Commands/
â”‚   â”œâ”€â”€ OpenORMDesignerCommand.ts     # Open designer command
â”‚   â”œâ”€â”€ ValidateORMModelCommand.ts    # Validation command
â”‚   â”œâ”€â”€ DeleteSelectedCommand.ts      # Delete elements command
â”‚   â””â”€â”€ RenameSelectedCommand.ts      # Rename element command
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ IssuesViewProvider.ts         # Issues panel
â”‚   â””â”€â”€ PropertiesViewProvider.ts     # Properties panel
â”œâ”€â”€ Designer/
â”‚   â”œâ”€â”€ ORMDesignerEditorProvider.ts  # Custom editor provider
â”‚   â”œâ”€â”€ ORMDesignerMessages.ts        # Message protocol types
â”‚   â””â”€â”€ ORMDesignerState.ts           # In-memory state management
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ IssueService.ts               # Issue management
â”‚   â”œâ”€â”€ SelectionService.ts           # Selection state
â”‚   â””â”€â”€ TFXBridge.ts                  # TFX framework integration
â””â”€â”€ Models/
    â”œâ”€â”€ DesignerSelection.ts          # Selection data structures
    â”œâ”€â”€ IssueItem.ts                  # Issue representation
    â””â”€â”€ PropertyItem.ts               # Property representation
```

### Message Protocol

The designer uses a typed message protocol for webview communication:

| Message Type | Direction | Purpose |
|--------------|-----------|---------|
| `DesignerReady` | Webview â†’ Extension | Webview initialization complete |
| `LoadModel` | Extension â†’ Webview | Send model data to render |
| `ModelLoaded` | Webview â†’ Extension | Confirm model loaded |
| `SaveModel` | Webview â†’ Extension | Request model persistence |
| `SelectElement` | Webview â†’ Extension | User selected an element |
| `SelectionChanged` | Extension â†’ Webview | Selection state updated |
| `UpdateProperty` | Extension â†’ Webview | Property value changed |
| `PropertiesChanged` | Webview â†’ Extension | Properties need refresh |
| `ValidateModel` | Either | Trigger validation |
| `IssuesChanged` | Extension â†’ Webview | Validation results updated |

### Context Menu Commands

**Designer Canvas:**
- `Dase.AddTable` â€” Add a new table to the model
- `Dase.AddRelation` â€” Add a relationship between tables
- `Dase.DeleteSelected` â€” Delete selected elements
- `Dase.RenameSelected` â€” Rename selected element

**Explorer (.dsorm files):**
- `Dase.OpenORMDesigner` â€” Open file in visual designer
- `Dase.ValidateORMModel` â€” Validate model and populate Issues

### Validation Rules

The ORM validator (using `XValidator<XORMDocument, XORMDesign>`) enforces:
- âŒ **Error:** Table name cannot be empty
- âŒ **Error:** Duplicate table names not allowed
- âŒ **Error:** Relation references non-existent table
- âš ï¸ **Warning:** Table has no columns defined

---

# ï¿½ğŸ“¦ TFX â€” Tootega Framework X

**TFX** is the core library that powers the DASE extension. It provides a robust, type-safe foundation for building VS Code extensions with complex visual designers.

## Architecture Overview

TFX is organized into four main modules:

### ğŸ”¹ Core Module (`@tootega/tfx/Core`)

The foundation layer providing essential building blocks:

| Class | Purpose |
|-------|---------|
| `XElement` | Base class for all hierarchical elements with parent-child relationships |
| `XPersistableElement` | Extended element with serialization, selection, and change tracking |
| `XProperty` | Reactive property system with metadata, validation, and binding support |
| `XEvent` | Type-safe event dispatching system |
| `XDispatcher` | Action executor with queuing capabilities |
| `XChangeTracker` | Undo/redo tracking for element modifications |
| `XValidation` | Validation framework with error severity levels |
| `XGuid` | GUID generation and manipulation utilities |
| `XConvert` | Type conversion utilities |

**Geometry Types:**
- `XPoint`, `XSize`, `XRect`, `XThickness` â€” Spatial primitives
- `XColor`, `XHSLColor`, `XBorderColor` â€” Color management
- `XFont`, `XFontStyle` â€” Typography support

### ğŸ”¹ Data Module (`@tootega/tfx/Data`)

Comprehensive XML serialization engine:

| Class | Purpose |
|-------|---------|
| `XSerializationEngine` | Central orchestrator for serialize/deserialize operations |
| `XSerializationContext` | Manages serialization state, references, and errors |
| `XElementRegistry` | Type registration for polymorphic serialization |
| `XmlWriter` | XML output generation with formatting options |
| `XmlReader` | XML parsing with namespace and attribute handling |
| `XTypeConverter` | Custom type conversion for serialization |

### ğŸ”¹ Design Module (`@tootega/tfx/Design`)

Visual design element primitives:

| Class | Purpose |
|-------|---------|
| `XDocument<T>` | Generic document container for designs |
| `XDesign` | Base class for design surfaces |
| `XDesignElement` | Base visual element with layout properties |
| `XRectangle` | Rectangle shape with borders and styling |
| `XLine` | Line element with cap and join styles |
| `XField` | Text field element |

### ğŸ”¹ Designers Module (`@tootega/tfx/Designers`)

Domain-specific designer implementations:

| Class | Purpose |
|-------|---------|
| `XORMDocument` | ORM model document container |
| `XORMDesign` | ORM design surface |
| `XORMTable` | Database table representation |
| `XORMField` | Table column/field definition |
| `XORMReference` | Table relationship/foreign key |

## Key Design Patterns

### Reactive Property System

TFX uses a sophisticated property system inspired by WPF/XAML:

```typescript
// Property registration with metadata
public static readonly NameProp = XProperty.Register<XORMTable, string>(
    (p: XORMTable) => p.Name,
    "guid-here",
    "Name",
    "Table Name",
    ""
);

// Property access via GetValue/SetValue
public get Name(): string {
    return this.GetValue(XORMTable.NameProp) as string;
}

public set Name(pValue: string) {
    this.SetValue(XORMTable.NameProp, pValue);
}
```

### Hierarchical Element Model

All elements inherit from `XElement`, providing:
- Parent-child navigation (`ParentNode`, `ChildNodes`)
- Type-safe child queries (`GetChild<T>`, `GetChildDeep<T>`)
- Tree traversal (`GetTree()`)
- Identity management (`ID`, `Name`)

### Change Tracking

Built-in undo/redo support through `XChangeTracker`:
- Automatic property change recording
- Transaction grouping
- State restoration

### Validation Framework

Declarative validation with `XDataValidateError`:
- Severity levels: `Warning`, `Error`
- Property-specific error binding
- Aggregated error collection via `XConcurrentBag`

## Usage

```typescript
import { XORMDocument, XORMTable, XORMField } from "@tootega/tfx/Designers";
import { XSerializationEngine } from "@tootega/tfx/Data";

// Create a new ORM document
const doc = new XORMDocument();
const table = new XORMTable();
table.Name = "Customers";
doc.Design?.AppendChild(table);

// Serialize to XML
const engine = XSerializationEngine.Instance;
const result = engine.Serialize(doc);
```

---

## ğŸ“œ Code Quality Standards

This project follows strict coding standards defined in [.github/copilot-instructions.md](.github/copilot-instructions.md).

### Quality Pillars (Priority Order)

1. **ğŸ”’ Secure** â€” Protection against common attacks
2. **âœ… Correct** â€” Bug-free, sound logic
3. **âš¡ Performant** â€” Minimal memory allocation (zero-allocation mindset)
4. **ğŸ“– Clear** â€” Self-documenting code (no comments needed)
5. **ğŸ¯ Consistent** â€” Uniform style across the codebase
6. **âœ¨ Elegant** â€” Aesthetically pleasing, easy to navigate
7. **ğŸ”§ Maintainable** â€” Easy to modify and extend
8. **ğŸ§ª Testable** â€” Designed for automated testing

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Classes/Types | `PascalCase` with `X` prefix | `XUserService`, `XORMTable` |
| Interfaces | `XI` prefix + `PascalCase` | `XIRepository`, `XISerializable` |
| Methods/Properties | `PascalCase` | `GetById`, `SaveChanges` |
| Private Fields | `_` prefix + `PascalCase` | `_Cache`, `_Repository` |
| Parameters | `p` prefix + `PascalCase` | `pUserID`, `pOptions` |
| Local Variables | Lowercase mnemonics | `lstua`, `frsrt` |

### Code Style Rules

- âœ… One type per file
- âœ… No braces for single-line blocks
- âœ… Early returns (guard clauses)
- âœ… No comments (self-documenting code)
- âœ… Avoid lambdas in hot paths
- âœ… Prefer explicit loops over LINQ
- âœ… Use `sealed` classes when inheritance not needed

---

## ğŸ—ï¸ Development Guide

### Prerequisites

- Node.js 20+
- VS Code (latest)
- TypeScript 5.3+

### TFX Development

```powershell
# Navigate to TFX directory
cd TFX

# Install dependencies
npm install

# Build the framework
npm run build

# Run tests
npm run test

# Run tests with coverage
npm run test:coverage

# Watch mode for development
npm run test:watch
```

**TFX Scripts:**

| Script | Description |
|--------|-------------|
| `npm run build` | Compile TypeScript to JavaScript (dist/) |
| `npm run watch` | Watch mode compilation |
| `npm run test` | Run all unit tests with Vitest |
| `npm run test:coverage` | Generate coverage report (100% required) |
| `npm run test:watch` | Interactive watch mode for tests |
| `npm run clean` | Remove build artifacts (dist/) |
| `npm run lint` | Run ESLint checks |

### DASE Extension Development

```powershell
# Navigate to DASE directory
cd DASE

# Install dependencies (includes local TFX)
npm install

# Build the extension
npm run compile

# Run tests
npm run test

# Run tests with coverage
npm run test:coverage

# Launch extension in VS Code
# Press F5 in VS Code, or:
code --extensionDevelopmentPath=./DASE
```

**DASE Scripts:**

| Script | Description |
|--------|-------------|
| `npm run compile` | Compile TypeScript to JavaScript (out/) |
| `npm run watch` | Watch mode compilation |
| `npm run test` | Run all unit tests with Jest |
| `npm run test:coverage` | Generate coverage report (100% required) |
| `npm run lint` | Run ESLint checks |
| `npm run package` | Create VSIX extension package |

### Running Both Projects

```powershell
# From repository root, build everything
cd TFX
npm ci
npm run build

cd ../DASE
npm ci
npm run compile

# Run all tests
cd ../TFX && npm run test:coverage
cd ../DASE && npm run test:coverage
```

---

## ğŸš€ CI/CD Pipelines

The repository maintains two independent CI/CD workflows:

### TFX Framework Pipeline

**Workflow:** [.github/workflows/tfx-ci.yml](.github/workflows/tfx-ci.yml)

**Triggers:**
- Push to `master` branch (TFX/** changes)
- Pull requests to `master` branch

**Pipeline Stages:**
1. **Checkout** â€” Clone repository
2. **Setup Node.js 20** â€” Configure Node.js environment
3. **Install Dependencies** â€” Run `npm ci` in TFX/
4. **Build** â€” Compile TypeScript (`npm run build`)
5. **Test** â€” Execute test suite with Vitest
6. **Coverage** â€” Generate and validate 100% coverage
7. **Upload Reports** â€” Publish coverage artifacts

**Quality Gates:**
- âœ… All automated tests must pass
- âœ… 100% code coverage required
- âœ… No TypeScript compilation errors
- âœ… Zero-allocation patterns enforced

### DASE Extension Pipeline

**Workflow:** [.github/workflows/dase-ci.yml](.github/workflows/dase-ci.yml)

**Triggers:**
- Push to `master` branch (DASE/** or TFX/** changes)
- Pull requests to `master` branch

**Pipeline Stages:**
1. **Checkout** â€” Clone repository
2. **Setup Node.js 20** â€” Configure Node.js environment
3. **Build TFX** â€” Build framework dependency
4. **Test TFX** â€” Validate framework integrity
5. **Install DASE Dependencies** â€” Run `npm ci` in DASE/
6. **Build DASE** â€” Compile extension (`npm run compile`)
7. **Lint** â€” Run ESLint checks
8. **Test** â€” Execute test suite with Jest
9. **Coverage** â€” Generate and validate 100% coverage
10. **Upload Reports** â€” Publish coverage artifacts
11. **Package** (master only) â€” Create VSIX extension package

**Quality Gates:**
- âœ… All automated tests must pass
- âœ… 100% code coverage required
- âœ… No TypeScript/ESLint violations
- âœ… TFX dependency integrity validated
- âœ… VSIX package builds successfully

**Artifacts:**
- Coverage reports (both TFX and DASE)
- VSIX extension package (master branch only)

---

## ğŸ“„ License

MIT License â€” See [LICENSE](LICENSE) for details.

---

<p align="center">
  <i>Built entirely through AI-driven development with GitHub Copilot</i><br>
  <b>ğŸ¤– No human wrote this code directly â€” only prompts ğŸ¤–</b>
</p>
